\documentclass{beamer}
\usepackage{graphicx}
\usepackage[math]{iwona}
\usepackage[no-math]{fontspec}
\usepackage{colortbl}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{color}
\newcommand{\ccntr}[1]{\multicolumn{1}{c}{\textbf{#1}}}

\usetheme{Dresden}
\usepackage{xunicode}
\usepackage{xltxtra}
\defaultfontfeatures{Mapping=tex-text}

\setmainfont[Path=/usr/share/texlive/texmf-dist/fonts/opentype/nowacki/iwona/,BoldFont=Iwona-Bold,ItalicFont=Iwona-Italic]{Iwona-Regular}
\setsansfont[Path=/usr/share/texlive/texmf-dist/fonts/opentype/nowacki/iwona/,BoldFont=Iwona-Bold,ItalicFont=Iwona-Italic]{Iwona-Regular}
\setmathrm[Path=/usr/share/texlive/texmf-dist/fonts/opentype/nowacki/iwona/,BoldFont=Iwona-Bold,ItalicFont=Iwona-Italic]{Iwona-Regular}
\setmathsf[Path=/usr/share/texlive/texmf-dist/fonts/opentype/nowacki/iwona/,BoldFont=Iwona-Bold,ItalicFont=Iwona-Italic]{Iwona-Regular}

\title{Configuration Pinocchio}
\subtitle{The Lies Plainly Seen and the Quest to be a Real Discipline}
\author{Andre Masella}
\date{May 15, 2015}

\begin{document}
\begin{frame}\maketitle \end{frame}

\begin{frame}\frametitle{Overview}
\begin{itemize}
\item Where are we?
\item SRSLY?
\item How do we get out?
\item Are we there yet?
\end{itemize}
\end{frame}

\begin{frame}\frametitle{When did configs get complicated?}
\begin{itemize}
\item In The Before Times, usually software was installed once and left alone.
\item Cloud and cluster computing means running the same things many ways.
\item Application have spread out beyond the binary~(\emph{e.g.}, into the database).
\item Testing is no longer possible by starting the binary on a work station.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Why are configs complicated?}
\begin{itemize}
\item Complexity is semantic and independent of the format.
\item There is a conflict between terse~(easy to write) and explicit~(easy to read).
\item Macro languages add additional behaviour.
\item There are strange embedded programming languages.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{What is a Configuration?}
\begin{itemize}
\item Configurations are usually generated by an \emph{ad hoc} process where constants in the code are externalised.
\item This including a configuration file, command-line arguments, built-time arguments, environment variables, and information in a database.
\item The format doesn't really matter. You can transform any of those to a ``config file''.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Terse and Explicit}
\begin{itemize}
\item Terseness is achieved two ways: macros and default propagation.
\item If the macro language is separate from the binary, the expansion can be observed. Often, it is built-in.
\item Default propagation works in many ways:
\begin{itemize}
\item elided parameters in parts of the configuration
\item values that override (in the config, environment, or on the command line)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Survey of Configurations}
\begin{itemize}
\item Examined common servers' configurations: Apache, NGINX, Samba, Asterisk, Make, BIND, and CUPS.
\item Looked at default propagation mechanisms and found:
\begin{itemize}
\item local stanza, global stanza, binary default~(implicit)
\item global stanza, local stanza, binary default~(implicit)
\item local stanza, template stanzas, binary default~(explicit)
\item hybrid~(Apache)
\end{itemize}
\item macro languages and embedded programming languages
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Survey of Configurations -- Highlights}
\begin{itemize}
\item Apache can change most of the configuration based on the query~(\emph{e.g.}, different security depending on the browser).
\item Apache and NGINX's rewriting rules are Turing complete! Roland Illig has implemented a Towers of Hanoi solver.
\item BIND has different default propagation schemes depending on the parameter.
\item BIND also has a rewrite system, though not Turing complete.
\item Make has contextually-determined lazy or eager evaluation.
\item Asterisk does \texttt{GoTo} via string bashing.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Weird Machines}
\begin{itemize}
\item If Apache's URL rewriting can be Turing complete, then every incoming URL is a program executed by the \texttt{mod\_rewrite} virtual machine.
\item URLs are a strange byte-code for a \emph{weird machine}.
\item Weird machines are targets for exploitation.
\item Many configurations define weird machines for the queries in the binary.
\item Since they are Turing complete, they can't be checked for correctness.
\item If they do things like Asterisk, where we compute jump targets from user data, that's scary.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Composability}
\begin{itemize}
\item Our configurations lack composability, which is what cloud configurations demand.
\item There should be a configuration that configures a server for running on metal \emph{and} in Docker.
\item We already have composition for some servers. LDAP queries as embedded in configurations.
\item String bashing needs to go away.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Solution: Divide and Conqueror}
\begin{itemize}
\item Separate the macro language and default propagation from the binary.
\item Make EPLs less weird and either using existing languages or more byte-code-like interfaces.
\item Make a configuration language that can handle the composition easily.
\item Creating a unified configuration format is not worth doing.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Not-So-Weird Machines}
\begin{itemize}
\item Replace weird machines with existing scripting languages~(\emph{e.g.}, Guile, Lua, FORTH, GameMonkey, TCL, JavaScript).
\item There are many obscure programming languages that few people know; when you create a new programming language, you can be guaranteed that no one will know it. -- K.~Schaffrick
\item If you really \emph{need} a machine, make it virtual, not weird.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Byte Code and Virtual Machine}
\begin{itemize}
\item Replacing weird machines with byte-code will be easier to:
\begin{itemize}
\item implement~(easy to parse, easy to build a simple VM)
\item optimise~(convert to LLVM/JVM/CLR)
\item verify and secure
\item debug~(crash and dump the machine state)
\item specify
\end{itemize}
\item People can also build good tools on top of it.
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Configuration Languages}
A language for configurations needs:
\begin{itemize}
\item have a sensible default propagation policy
\item composability in the face of multiple binaries and formats
\item be semantically meaningful
\item the features of normal languages~(\emph{e.g.}, types, debugging, libraries)
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Why not use traditional languages?}
\begin{itemize}
\item They aren't very good at it!
\item Imperative languages make determining data flow our problem, but we don't care.
\item Functional ones require us to know lots about the format of our data, which we don't know and will change.
\item They are concerned about I/O and a whole bunch of other things that are unhelpful for configurations.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Existing Configuration Languages}
\tiny
\begin{tabular}{lcccc}
\hline
										& Coil						& Flabbergast$^\dagger$& HOCON					& Jsonnet		\\\hline
Paradigm						& Functional			& Functional					& Imperative$^*$&	Functional	\\
Side-effect Free		& Yes							& Yes									& No						&	Yes					\\
Inheritance					& Prototype				& Prototype						& Prototype			&	Prototype		\\
Typing Strength			& Weak						& Strong							& Weak					&	Strong			\\
Typing Enforcement	& Dynamic					& Dynamic							&	Dynamic				&	Dynamic			\\
Schema Validation		& None						& None								& None					& None				\\
Turing Complete			& No							& Yes									& No						& Yes					\\
Scoping							& Lexical					& Dynamic							& Lexical				& Lexical			\\
Default Propagation	& Inheritance			&	Scope, inheritance	& Inheritance		& Inheritance	\\
Output Format				& Python objects	&	Text, Custom				& Java, Python, or Ruby objects & JSON		\\
\hline
\end{tabular}\\
\begin{tabular}{lccc}
\hline
										& NixOS				& Pan & Pystachio \\\hline
Paradigm						& Functional	& Imperative			& Imperative \\
Side-effect Free		& Yes					& No							& Hybrid$^*$ \\
Inheritance					& None				& Class-based			& Class-based \\
Typing Strength			& Strong			& Strong					& Strong \\
Typing Enforcement	& Dynamic			& Hybrid$^*$			& Dynamic \\
Schema Validation		& None				& Assignment			& Request \\
Turing Complete			& Yes					& Yes							& No \\
Scoping							& Lexical			& Lexical					& Hybrid$^*$ \\
Default Propagation	& Operator		& Inheritance			& Inheritance \\
Output Format				& Java objects			& JSON, XML				& Python objects \\
\hline
\end{tabular}\\
$^*$ Depends on context.
$^\dagger$ Mine.
\end{frame}

\begin{frame}\frametitle{Existing Configuration Languages}
\begin{itemize}
\item Most are functional.
\item Most use prototype inheritance.
\item More dynamic scoping than expected.
\item Some schema validation.
\item All are very immature.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Conclusion}
\begin{itemize}
\item Stand back and decide what your config files \emph{really} are.
\item Stop the weird machines.
\item Delegate the configuration manipulation to a configuration language.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Thanks}
\begin{itemize}
\item Kyle W.~Schaffrick, Google, Inc.
\item Dr.~Gr\'ainne Sheerin, Google, Inc.
\item Dr.~Dan G.~Brown, University of Waterloo
\item James L.~Schofield, Couch Labs, Inc.
\end{itemize}
\end{frame}

\end{document}
